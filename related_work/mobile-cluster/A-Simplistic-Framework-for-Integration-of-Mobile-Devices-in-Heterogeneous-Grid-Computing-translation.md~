#Abstract
**モバイルデバイスをグリッドコンピューティングに組み込むことには多くのメリットがありますが、現在の実装は複雑すぎるか、あまりにも細かいため、小規模から中規模の組織で効率的に使用することはできません。**

 さらに、プラットフォームや開発環境の多様性や、ハイエンドモバイルデバイスの仮想的な存在がここ数年になるまでには、実際のグリッドにモバイルデバイスを組み込むことが困難でした。

 **ここでは、複雑な計算問題を実行するために使用される異種グリッドコンピューティング（デスクトップボランティアグリッドコンピューティングシステム、DGVCS）におけるモバイルデバイスをワークステーションとして統合するための新しい単純化されたフレームワーク "jUniGrid"を紹介します。**

**jUniGridは、Java対応デバイス（モバイルなど）をグリッドノードとして展開するために設計された柔軟なグリッドアーキテクチャです。**

#1 intro

当初、グリッドは、ハイエンドコンピューティングへの簡単で安価なアクセスを提供するインフラストラクチャとして定義されていました。

その後、共同の問題解決のためのリソースを共有するインフラストラクチャとして洗練されました。

最近では、Gridの定義はリソースをプールし仮想化するインフラストラクチャとして進化し、透過的な方法でそれらの使用を可能にしています[19]。

グリッド・コンピューティングは、コンピューティング・パワーの指数関数的な需要に追いついてコストを抑えるため、いくつかの競争優位性を備えたスーパーコンピューティングの重要な代替手段として浮上しています[2,20,22,23]。

**実際、ボランティア・コンピューティング（VC）プラットフォームは、地球上の最大かつ最も強力な分散コンピューティング・システムの1つであり、さまざまな科学分野（計算生物学、気候予測、高エネルギー物理学など）からアプリケーションを実行している[23]。**

モバイルグリッド（従来のグリッドとは対照的に）は、モバイルコンピューティングデバイス（特にスマートフォンとタブレット）で利用可能なコンピューティングパワーを利用します。

**モバイルグリッドインフラストラクチャ[4、30]は、モバイルデバイスとグリッド環境の統合を提案している[4,30]。**
この提案は、グリッドと対話する2つの可能性を有する。**（1）モバイルデバイスは、グリッド（例えば、グリッドポータル）へのアクセスインタフェースとして、または（2）モバイルデバイスは、処理および/または他のリソース設備を提供するグリッド用のリソースとして配備されてもよい。**

**モバイルノードは、現在のように大規模/大チャレンジアプリケーション向けの高性能分散コンピューティング施設に参加する最良の選択肢ではないかもしれないが、**
非常に印象的な計算性能を提供します（3Dレンダリングやマルチメディア

**これらのデバイスは継続的に電源が供給され、潜在的な割り当てが可能であるため、グリッド・コンピューティング・アプリケーションのベスト・プラクティスではないにしても、公平です。**(As  these  devices  are  continuously  powered and available for potential assignments, they are fair, if not the best,  candidates  for  grid  computing  applications. )

さらに、この記事の後半で説明するように、「モバイルグリッド」は、利用可能なモバイルデバイスのみを活用するわけではない
**さまざまな展開シナリオで追加のコンピューティングパワーを提供するだけでなく、オンデマンドのアドホックグリッドコンピューティングソリューションを作成するための効率的な手段を提供します。**

ビジネスプロセスの観点からは、これはモバイルノードがワークフローアクティビティ（タスク提出など）に直接関与できることを意味します。

**したがって、モバイルグリッドは、グリッドをモバイルデバイスに拡張するためのコンテンツ配信およびポータルベースのアプローチ（現在の実装では一般的なプラクティス）を克服する必要があります[34]。**

#2 related works
GlobusToolkit [11,38]、Legion [15]、Condor [28]、GridGain（www.gridgain.com/）といったグリッドソフトウェアの開発には、いくつかのフレームワーク/ API /ツールキット/ミドルウェアが利用可能です。
**これらのフレームワークは、「サービスグリッド」（例えば、EGEE）および「デスクトップグリッド」（BOINCおよびXtremWebなどのボランティアコンピューティング）と呼ばれる主に2つのタイプのシステムを提供することを意図している。**
.
.
.
.
(最後)
前述の多くの問題は、モバイルグリッドコンピューティングのための特別なフレームワークを開発するというアイデアに関連していますが、**モバイルデバイスを利用するためのより良いアプローチは、デスクトップシステムと同様にノードとして参加させることです。 補足/追加リソース。**

 **このアプローチを説明するために、DGVCSを向上させるためのモバイルデバイスのコンピューティング能力を活用したり、スタンドアローンのデスクトップ/モバイル/異機種グリッドとしてグリッドアプリケーションを開発するための、非常に軽いフレームワーク/ APIをご紹介します。**

#3 CHALLENGES AND OBJECTIVE
モバイルデバイスをグリッドに統合することの潜在的な利点は、多くの技術的困難を解決することにかかりますが、最近では他の多くの論文や研究プロジェクトのテーマとなっていますが、これらのいずれも、この統合をサポートする実装方法論を提供していません。

- **Availability:**
これらのデバイスの主な目的はコンピューティングではなく、それらが「モバイル」であるという事実は、**長時間の計算目的では「ローカル」で利用できないことを意味します。**
さらに、これらの装置は「バッテリ駆動」であるため、バッテリ寿命もまた大きな問題である。

**グリッドコンピューティングにおけるモバイルデバイスの使用には、以下の課題があります。**

- **Processing  capability:**
モバイルの性能は向上している
しかし、**これらはRAMやローカルストレージでは依然として劣っているため、**計算グリッドは大規模なリソース共有に基づいているため、**データグリッドではなく計算グリッドでの使用が制限されています。** 計算ノード[32]

- **Platform:** 
さまざまな目的のために、異なるベンダーによって開発されたモバイルデバイスは、異なるオペレーティングソフトウェア（OSがクローズドソースであることが多い）を実行し、一部のソフトウェア開発ツールは完全に利用できません。
現在の調査の目的は、マルチプラットフォームの操作性、**すなわちソフトウェアおよびハードウェアの異種性のサポートを可能にする協調処理のための基本的な汎用グリッド機構を提供することである。**

ここで、**マルチプラットフォームとは、計算能力を備え、適切な通信機構（例えば、Wi-Fi、GPRS、有線LAN）を介してグリッドに接続可能な任意のデバイス**（以下、特に明記しない限り、ワークステーションまたはノードと呼ばれる） 等。）"。
**実際には、上記で議論されたプラットフォームの多様性問題に対抗するためのJavaのサポートなど、いくつかの前提条件が存在します。**

さらに、「可用性」、「処理能力」および「接続性」に関する主要な懸案事項に対処できる**動的なスケーラビリティ（ノードのオンザフライでの追加または削除）のサポートも重要な基準です。グリッドサイズは、 動的に変更され、タスクの複雑さとリソースの可用性に左右されます。**

ここではjUniGridを紹介します。
--モバイル＆固定コンピューティングデバイス用のグリッドアプリケーションを開発するための汎用フレームワーク（API）。

グリッドは、2つの異なるアプリケーション、すなわち、タスク - サブミッターTS（通常の配備ではグリッドごとに1つのTSインスタンス）とノード - アプリケーションNA（すべてのノード/ワークステーションで1つ以上のインスタンス）を使用して動作します。
一緒に働くと、それらは集合的にグリッドアプリケーションとして機能します。 両方のアプリケーションは、モバイルデバイスまたはデスクトップシステムの任意の組み合わせで展開できます。

NAとTSは、有線または無線ネットワーク技術の任意の組み合わせによって接続できます。
NAはジョブを実行し、その結果をTSに提出する。

TSは、ノードを登録および追跡し、NAにジョブを分配し、NAの状態を監視し、結果を収集する。

jUniGridはMap / Reduce（スプリット/マージ）アルゴリズムに基づいて動作します。

ジョブの要件に応じて、ジョブを分割して結果をマージする柔軟性をユーザーに提供します。

このスプリットとマージは、ユーザー定義のTSによって実行されます。

TSは3つのモジュールで構成され、その責任は以下で説明されます。

- Job Allocation:
- Job Monitoring:
**jUniGridなどのシンプルなフレームワークのジョブ監視は、グリッドに接続しているときにデバイスが応答しなくなる状況でのみ必要です。**
アプリケーション計算に使用される可能性がある計算能力を掃除する(かきあつめる)という意味では冗長であることが判明する可能性があります。
**それにもかかわらず、冗長かどうかにかかわらず、スケールアップが予想されるグリッドに対しては監視システムが必要です。**

- Result Aggregation:

次に、タスク・サブミッタ（TS）とノード・アプリケーション（NA）の実行フローと通信について説明します。

- 1.[Task Submitter]
開始時に、TaskInfoManagerはjobListを作成します。
JobListにはGridJobInfoのオブジェクトが含まれています。
GridJobInfoオブジェクトは、JobHeaderとJobBodyで構成されます。
NodeHandlerは設定されたソケットをリッスンし、ノードからの接続要求を待機します。

- 2.[ノード]

開始時に、ノードは成功するまでタスク・サブミッターとの接続を継続的に要求します。
一旦接続が確立されると、合成信号「Requrest_For_Job」を送信し、ジョブがGridJobInfoオブジェクトの形で受信されるまで待機する。

- 3.[Task Submitter]

NodeHandlerがNodeから要求を受け取ると、NodeInfoManagerに通知してNodeListを更新します。
要求ノードのIPがNodeListにまだ登録されていない場合、NodeInfoManagerはリクエスタを新しいノードと見なします。 NodeHandlerはJobListを参照し、リクエスタにジョブをFIFO形式で割り当てます。
**すべてのジョブのステータスは、NodeHandlerによって監視/管理されます。**
JobListの新しいジョブエントリはそれぞれ、InQueueステータスを保持します。
割り当てが完了すると、ステータスは割り当て済みに変更されます。

**ノードとの接続が切断された場合、ジョブの状態は失敗として反映されます。**
ノードが完了してジョブを戻すと、ステータスは完了します。
ジョブのFIFO割り当てで。InQueueステータスのジョブがない場合、失敗したジョブはすべてInQueueステータスに変換されます。

**NodeHandlerは、割り当てられたジョブに関するNodeからの応答を待ちます。**

- 4.[Node]
GridJobInfoオブジェクトの形式でジョブを受け取ると、ノードは受け取ったGridJobInfoオブジェクトのExecuteメソッド（実際の処理 - ユーザによって指定されている）を呼び出し、GridJobInfoオブジェクトのJobBodyに結果が格納され、JobHeaderは それに応じて更新され、ノードは処理の完了を通知される。

通知されたノードは、GridJobInfoオブジェクトをTask Submitterに返し、その後にNewジョブの要求を返します。
このプロセスは、ノードがグリッドと同等になるまで無限に繰り返されます。

- 5.[Task Submitter]
NodeHandlerがGridJobInfoオブジェクトの形でNodeから完了したJobを受け取ると、JobListを更新し、個々のジョブの完了をユーザに通知するか、ユーザが指定した結果をさらに処理するために処理を進めます。

上記の交換は、すべてのジョブが完了するまで繰り返します。
**JUniGridフレームワークを実装するには、jUniGrid APIを使用して2つのアプリケーションTSとNAを開発する必要があります。**
実際の計算部分は、ジョブ・クラスでコード化されている
以下：


#5 BENCHMARKING, RESULTS AND DISCUSSION
.
.
.
**図5と図6のデータは、このような簡単なテストケースで負荷分散が自動的に達成されることも示しています。**
.
.
.
アンドロイド携帯電話は、単一のコンピュータシステムの約1/3の速さでジョブを実行することが可能であり、携帯電話の限られたリソースを考慮すると実質的である。
また、3つのネクサスの1つのコンピュータシステムを1つのデバイス（または同様の容量デバイス）グリッドに置き換えてモバイルノードとすることにも注意する。
.
.
.
しかし、実際の実装では、ネットワークアプリケーションのレイテンシ、さまざまなデバイスの計算能力範囲、RAMの使用状況、アプリケーションの安定性に関して、ノードアプリケーションとジョブを最適化することができます。
.
.
.
**また、ノードの数は動的に変更することができ、すなわち、グリッドが処理されている間でもノードを追加/削除することができる。**
そのようなアドホック・グリッドのアップスケール拡張は、イントラネットまたはインターネット環境で利用可能な無料のリソースを利用する「モバイル/デスクトップ・グリッド＆ボランティア・コンピューティング・システム（M / DGVCS - 従来のDGVCSに類似している） 大規模な計算（およびうまくいけばストレージ）をサポートします。
2番目のシナリオは、既存のグリッドシステムのオンデマンド展開です。
かなりの費用（追加のハードウェア）なしで従来のグリッドシステムを拡張することは一般的に容易ではない。
**グリッドに携帯電話を追加すると、特にグリッドの物理的な拡張が技術的、地方的または財政的な問題のために不可能な重大な状況において、既存のグリッドの性能が向上する可能性があります。**

**ベンチマークテストで観察されたように、既存のグリッドに接続されたアンドロイドモバイルは、従来のノード（PC /ラップトップ）と比較して約30％の計算能力を提供することができます。
したがって、クリティカルな状況では、オンデマンドでパフォーマンスを大幅に向上させることができます。
これにより、小規模なグリッドではパフォーマンスが大幅に向上し、処理能力の向上が目立つようになります。**

#6 CONCLUSION
**本稿では、モバイルグリッドコンピューティングの課題を調査し、グリッドアプリケーションを開発するための軽量アーキテクチャ/ APIの形式で実現可能なソリューションを紹介しました。**
フレームワークは普遍的に適応可能であるが、その使用は、ネットワーク化されたモバイルデバイスによって生成されたリソースの可能性を切り分けるために、従来型またはアドホック異種実装のモバイルデバイスを統合することを主な目的としている。

パフォーマンスの問題はその重要性が認められ、適切な予備的なベンチマークテストによって検討されています。
**また、モバイルグリッドを概念的な解決策ではなく現実の世界として実装するためのさまざまな展開シナリオとユースケースについても説明します。**



