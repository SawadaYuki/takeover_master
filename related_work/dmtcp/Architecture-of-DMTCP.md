#Architecture of DMTCP

これは、DMTCPのアーキテクチャを穏やかに紹介することを意図しています。
より短い説明が可能です。

実装のコードへの参照を含む低レベルの記述については、doc / restart algorithm.txtを参照してください。

プラグインの一般的な使用については、doc / plugin-tutorial.pdfを参照してください。 DMTCPは、DMTCP ROOT / src / pluginの内部でプラグインを使用します。

DMTCPはオプションのプラグインも提供しています（デフォルトでは有効になっていません）。

Thesには2つの味があります：
DMTCP ROOT /プラグイン（完全にサポートされている）とDMTCP ROOT / contrib（おそらくサードパーティによって提供された新しいプラグイン）。


#2. dmtcp launch a.out
コマンドdmtcp launch a.outは、次のコマンドとほぼ同じです。
1：dmtcpコーディネーター - バックグラウンド（まだ実行されていない場合）
2：LD PRELOAD = libdmtcp.so a.out
dmtcpの起動コマンドは、デフォルトのDMTCPポートを使用してローカルホスト上でコーディネータプロセスを起動させます（まだ使用できない場合）。

DMTCPは多数のコンピュータ間で分散計算をチェックポイントできるため、DMTCPはコーディネータプロセスを実装します。

ユーザーはコーディネーターにコマンドを発行し、コーディネーターはそれを中継します。
コマンドを分散計算の各ユーザプロセスに送信する。

DMTCP計算は、コーディネータプロセスと、そのコーディネータに接続されたユーザプロセスのセットと定義されることに留意されたい。

したがって、1台のコンピュータ上で複数のDMTCP計算を行うことができ、各計算にはそれぞれ固有のコーディネータがあります。

コーディネーターはステートレスです。
計算が絶滅した場合は、まったく新しいコーディネータを開始してから、各ユーザープロセスの最新のチェックポイントイメージを使用して再起動する必要があります。


--
LD PRELOADは、ローダが認識できる特別な環境変数です。

ローダがバイナリ（この場合a.out）をロードしようとすると、ローダはまずLD PRELOADがセットされているかどうかをチェックします（ 'man ld.so'参照）。

これが設定されている場合、ローダーはa.outで 'main（）'ルーチンを実行する前に、バイナリ（a.out）とプリロードライブラリ（libdmtcp.so）をロードします。

（実際、dmtcpを起動すると、pidvirt.so（DMTCP-2.0で始まる）などのプラグインライブラリがプリロードされ、DMTCP DLSYM OFFSETなどのいくつかの環境変数が設定される可能性があります

ライブラリlibdmtcp.soがロードされると、ユーザーmain（）を呼び出す前にトップレベルの変数が初期化されます。

最上位変数がC ++オブジェクトである場合、C ++コンストラクタはユーザmainの前に呼び出されます。

DMTCPでは、最初に実行するコードはlibdmtcp.soの中の以下のコードです。

dmtcp :: DmtcpWorker dmtcp :: DmtcpWorker :: theInstance（true）;
これにより、新しいdmtcp :: DmtcpWorker :: DmtcpWorker（true）の呼び出しを介してグローバル変数theInstanceが初期化されます。
（ここでは、dmtcpはC ++名前空間で、最初のDmtcpWorkerはクラス名ですが、2番目のDmtcpWorkerはコンストラクター関数です。
DMTCPがC ++を使用していない場合は、直接GNU gcc属性を使用してコンストラクタ関数を直接実行する方法を使用します。


DMTCPは少なくとも2つのレイヤーで構成されています。

最下層はMTCP（mtcpサブディレクトリ）で、シングルプロセスチェックポイントを処理します。
上位層はDMTCP（dmtcpサブディレクトリ）とも呼ばれ、1つのプロセスをチェックポイントする必要があるときにMTCPに委譲します。

MTCPは別個のDMTCPコーディネータを必要としません。

**NOTE: As of DMTCP-2.2、多くの機能が移動されました。**
見るべき重要なファイルは次のとおりです。
src / mtcp / mtcp restart.c、src / mtcp / restore libc.c、およびsrc / threadlist.cppを参照してください。
起動時には、次のように表示されます。

**PRINCIPLE: **
任意の時点で、ユーザースレッドがアクティブであり、チェックポイントスレッドがselect（）でブロックされているか、チェックポイントスレッドがアクティブで、ユーザースレッドがシグナルハンドラstpthisthread（）内でブロックされています。

**3. Execute a Checkpoint:**

**4. Checkpoint strategy (overview)**

**5. Principle: DMTCP is contagious**

**6. Principle: One DMTCP Coordinator for each DMTCP Computation**
1つのホスト上で複数のDMTCPベースの計算を実行したい場合があります。

これは、dmtcp起動またはdmtcpコーディネータの--hostフラグと--portフラグを使用することで簡単に実行できます。

 指定しない場合、デフォルト値はlocalhostとport 7779です。

dmtcpコマンドを使用すると、チェックポイントやその他の要求を優先コーディネータに伝えることができます（デフォルトのコーディネータを使用していない場合は、ホストとポートを指定します）。

最も簡単な場合、ユーザーはフラグなしでdmtcpの起動のみを呼び出します。 dmtcp launchコマンドは、localhost：7779にある既存のコーディネーターを探します。


どれも見つからない場合、dmtcpは、これらのデフォルト値localhost：7779を使用してdmtcpコーディネーターを呼び出します。

したがって、同じホスト上の2人のユーザーがそれぞれデフォルトのパラメータでdmtcpを起動すると、時折問題が発生します。

同じコーディネーターを使用することはできません。同様に、1人のユーザーが2つの独立した計算を開始し、それらを独立してチェックポイントすることができます。

ユーザーが両方の計算でdmtcpの起動（デフォルトのパラメータ）を起動すると、コーディネータは1人しか存在しません。

したがって、DMTCPの観点から見ると、1つの計算しか存在せず、チェックポイントコマンドは両方の計算のプロセスをチェックポイントします。

#7. Plugins, and other End-User Customizations
**DMTCP Plugins.**
DMTCPプラグインは、DMTCPをカスタマイズする最も一般的な方法です。

例はDMTCP ROOT / test / plugin /にあります。 DMTCPの動作を変更するために、ダイナミックライブラリ（* .so）ファイルが作成されます。

ライブラリは、追加のラッパー関数を書くことができます（さらに、以前のラッパー関数の周りにラッパーを定義することもできます）。

ライブラリーは、DMTCPイベントの通知を受けるように登録することもできます。 この場合、DMTCPはイベントごとに登録されたプラグイン関数を呼び出します。

重要な事象の例は、例えば、 チェックポイントの前、再開後、およびチェックポイントイメージからの再起動後に実行されます。

この執筆時点では、すべてのDMTCPイベントの中央リストはなく、イベントの名前は変更される可能性があります。

プラグインライブラリはlibdmtcp.soのあとにプリロードされます。

プリロードされたすべてのライブラリと同じように、ユーザの "main"関数の前に自分自身を初期化することができます。実行時にはlibc.soなどの標準ライブラリ関数の前に、標準のLinuxライブラリ検索順序でプラグインラッパー関数が見つけられます。

たとえば、sleep2プラグインの例では、2つのプラグインを使用しています。 プラグインをビルドした後は、
次のように：

dmtcp launch --with-plugin \
PATH/sleep1/dmtcp sleep1hijack.so:PATH/sleep2/dmtcp sleep2hijack.so a.out

より複雑な例では、./configure --enable-ptrace-supportが指定されると、DMTCPはプラグインDMTCP ROOT / plugin / ptrac /ptracehijack.soを使用します。
現在、PID / TID仮想化を提供する新しいプラグインが計画されています。
ptraceのサポートと同様に、PID / TID仮想化のためのよりモジュラーな構造が維持しやすくなります。

**Dmtcpaware. **
dmtcpawareインターフェースは、DMTCP-2.2以降ではもはやサポートされなくなった旧式のカスタマイズ機構です。

**MTCP.**
DMTCP-2.1以前のバージョンでは、DMTCPのMTCPコンポーネントをコンパイルしてスタンドアロンで実行することができ、弱いシンボルを使用してフック関数を実行する機会が得られました。
MTCPはほぼ完全に書き直され、現在はDMTCPと緊密に統合されています。
以前のMTCPアーキテクチャ（チェックポイントスレッドだけで、別のコーディネータは使用しない）を使用したい場合は、これらの機能を備えたプラグインが将来計画されています。

#8. Implementation of Plugins

DMTCP実装の一部であるラッパー関数とpid / tid仮想化の実装技術は、DMTCPの初期提供後もそれほど長くはありません。
最近では、この機能性がプラグインの高レベル抽象化に包まれています。
このセクションでは、これらの機能の実装を強調しています。
プラグインの使用方法や独自のプラグインについては、doc / plugin-tutorial.pdfを参照してください。

#a. Wrapper functions
ラッパー関数は、関数を中心とする関数です。

DMTCPはlibc.so関数の周りに関数を作成します。

ラッパー関数は、通常、dlopen / dlsymを使用して作成されます。

 たとえば、libc：fork（）のラッパーを定義するには、libdmtcp.soの関数fork（）を定義します（execwrappers.cppのextern "C" pid t fork（）を参照）。

この例を続けると、ユーザーコードがfork（）を呼び出すと、次のような進行が表示されます。

a.out：fork（） - > libdmtcp.so:fork（） - > libc.so:fork（）を呼び出します。
libdmtcp.soがlibc.so：forkの前にlibdmtcp.soがlibc.soの前にロードされたため（LD PRELOADのため）、ライブラリの検索順序でシンボルが表示されます。

次に、pthread createのラッパーは、作成された新しいスレッドのスレッドIDを覚えています。

フォークのラッパーは、環境変数LD PRELOADがlibdmtcp.soに設定されていることを保証します。

LD PRELOADに現在libdmtcp.soが含まれていない場合、fork（）の呼び出しの前にlibdmtcp.soをインクルードするようにリセットされ、fork（）の後にLD PRELOADが元のユーザー値にリセットされます。

システムのラッパー（リモートプロセスを作成する場合）はおそらく最も興味深いものです。

 通話システムの説明については、「man system」を参照してください。例えば ​​"ssh REMOTE HOST a.out"のような引数を調べ、システムを呼び出す前に "ssh REMOTE HOST dmtcp launch a.out"への引数を編集します。

もちろん、これはdmtcpの起動がREMOTE HOST上のユーザーのパスにある場合にのみ機能します。これは、ユーザーまたはシステム管理者の責任です。


**c. Publish/Subscribe**

プラグインは、DMTCP計算に複数のプロセスが含まれており、ユーザープロセスが互いに調整しなければならない状況で、パブリッシュ/サブスクライブサービスも提供します。
詳細はdoc / plugin-tutorial.pdfにあります。

