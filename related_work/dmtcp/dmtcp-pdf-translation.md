# DMTCP
##Abstract
DMTCP（分散型マルチスレッド・チェックポイント）は、分散アプリケーションのためのtransparent(分かりやすい)ユーザーレベルのチェックポイントパッケージです。

一般的なデスクトップアプリケーションと同様に,DMTCPは多数のノード、プロセス、およびスレッドからなる一般的なクラスタの計算をチェックポイントします。

実験結果は、ノード数が中規模のクラスタに増加するにつれて、チェックポイント時間はほぼ一定のままであることを示しています。

DMTCPは **fork, exec, ssh, mu-texes/semaphores, TCP/IP sockets, UNIX domain sockets, pipes, ptys (pseudo-terminals), terminal modes, ownership of controlling terminals, signal handlers, open file descriptors, shared open file descriptors, I/O (including the readline library), shared memory (via mmap), parent-child process relationships, pid virtualization, and other operating system artifacts**を把握する

**非特権モード、つまりユーザーレベル**でのアプローチにより、Linuxカーネルの2.6.9 ~ 2.6.28までの互換性が保持される

DMTCPは非特権であり、特別なカーネルモジュールやパッチを要求しないため、
いくつかの大きなパッケージ内のチェックポイントリスタートモジュールとして組み込まれる、もしくは配布されています。

##1.intro

現在最も広く使用されているシステムとは異なり、DMTCPはユーザーレベルであり、システム特権を必要としません。
ここで説明されているアプローチでは、強力なコンピュータやクラスタ上で計算処理のCPU負荷の高い部分を即座に実行し、家庭や航空機でのインタラクティブな分析のために計算を単一のラップトップに移行することができます。

チェックポインティングは、堅牢な方法で解決するのが本質的に難しい問題です。 今日最も広く使用されているチェックポイントアプローチは、カスタムカーネルモジュールに基づいています。
**カーネルモジュールは、標準APIよりも急速に変化するカーネルの内部に直接アクセスするため、維持するのが難しい。**カーネルの変更に基づく試行の大半は、現在のカーネルバージョンでは機能しません。カーネル固有のチェックポイント方式を維持するために大量の人力を費やすことは合理的です。これにより、多くのバッチ・キューがチェックポイント機能を利用できるようになるのですが、対照的に、「デスクトップ上のチェックポイント機能」は現在広く普及していません。

DMTCPは、従来の高性能アプリケーションと一般的なデスクトップアプリケーションの両方をサポートしようとします。 これを念頭において、DMTCPは透過性の重要な機能をサポートしています。

**アプリケーションバイナリにはroot特権が必要なく、新しいカーネルに再設定する必要はありません。**

### 1.1 use Cases
1)save / restore workspace：対話型言語には、頻繁に独自の「保存/復元作業領域」コマンドが含まれています。 DMTCPはその必要性を排除します。

3) PRELINKの代替品：PRELINKは、多くの大規模な動的ライブラリが呼び出されるときの起動時間を節約するために、アプリケーションを事前にリンクするためのLinuxテクノロジです。 PRELINKは、変化するLinuxアーキテクチャと同期して維持する必要があります。

8) 堅牢性：分散デッドロックまたはレースを検出すると、自動的に以前のチェックポイントイメージに戻って、危険ポイントを超えるまで、より遅い「セーフモード」で再起動します。

## 2. Related work
チェックポイント・パッケージには長い歴史があります（カーネル・レベルとユーザー・レベル、コーディネートされたものとコーディネートされていないもの、シングルスレッドとマルチスレッドなど）。

スペースの制約から、他の多くのアプローチの中でも最も重要な点のみを強調しています。
DejaVu [29]（その開発はDMTCPの開発と重複しています）は、ソケットに基づいた分散プロセスの透過的なユーザーレベルのチェックポイントを提供します。

しかし、DejaVuはDMTCPよりもはるかに遅いようです。

例えば、Chomboベンチマークでは、Ruscio et al。 45％のオーバーヘッドで1時間に10個のチェックポイントを実行することを報告します。

比較すると、同様のスケールのDMTCPのベンチマークでは、通常、チェックポイント間のオーバーヘッドが本質的にゼロで、2秒でチェックポイントが発生します。

それにもかかわらず、DejaVuはカスタマイズされたバージョンのMVAPICHを使用してInfiniBand接続をチェックポイントすることもできます。

  DejaVuは、すべての通信をログに記録し、ページ保護を使用してチェックポイント間のメモリページの変更を検出することにより、DMTCPより侵略的なアプローチを採用しています。

これは、DMTCPに存在しない通常のプログラム実行中の追加のオーバーヘッドを説明します。

この記事の執筆時点でDejaVuは一般公開されていないため、共通のベンチマークで直接タイミングを比較することはできませんでした。

**チェックポイントのためのユーザレベルのMPIライブラリ[4]、[5]、[12]、[14]、[15]、[32]、[34]、[36];**
分散プロセスのために機能しますが、MPI（Message Passing Interface）を通じて排他的に通信する場合に限ります。

**カーネルレベル（システムレベル）のチェックポイント[13]、[16]、[18]、[19]、[30]、[31]**
パッケージバージョンをカーネルバージョンに一致させるための要件。

通常、特定のMPIの方言に制限されています。

**これらの2つのカテゴリの間のクロスオーバは、カーネルレベルチェックポインタBLCR [13]、[30]である。**
BLCRは、その広範な使用のために特に注目に値する。

**BLCR自体は、単一マシン上のプロセスだけをチェックポイントできます。**
しかし、一部のMPIライブラリ（OpenMPI、LAM / MPI、MVAPICH2、MPICH-Vの一部のバージョンを含む）は、分散チェックポイント機能を提供するためにBLCRと統合することができます。

**分散チェックポイントに加えて、単一のプロセスチェックポイント[1] [2] [6] [8] [20] - [22] [24] - [26]を実行する多くのパッケージが存在する。**

完全性のために、仮想マシンの補完的な技術にも注目します。

VMwareの一例として、仮想マシンにスナップショットと記録/再生の両方の技術を提供しています。

**DMTCPのプロセスレベルチェックポイントは、本質的に軽量ソリューションです。

さらに、プロセスレベルのチェックポイント機能により、分散アプリケーションをサポートしやすくなります。**

VMware Playerはインストール時にシステム特権を必要としますが、その後スナップショットと記録/再生をユーザーレベルで使用できます。
チェックポイントの詳細については、次の調査[10]、[17]、[28]を参照してください。

## 3. Usage and Features

### 3.1 Programming Interface
**DMTCPは未修正のLinux実行ファイルをチェックポイントすることができます。**
ただし、チェックポイント処理をより詳細に制御したい場合は、dmtcpaware.aというDMTCPとやりとりするためのライブラリを用意します。

## 4. Software Architecture
DMTCPは、我々の以前の研究(MTCP)に基づいています。
**MTCPには個々のプロセスのチェックポイント処理の責任**が割り当てられ、**DMTCPチェックポイントはソケット/ファイル記述子やその他の分散ソフトウェアのアーティファクト(アイテム)**を復元します。

### 4.1. Design of DMTCP

1) DMTCPは、多くのノードに分散しているプロセスのネットワークのチェックポイントを可能にします。**DMTCPはすべてのプロセス間情報をユーザー空間にコピーした後、単一プロセスのチェックポイントを別のチェックポイントパッケージに委任します。**

2) **過去の研究MTCPをシングルプロセスチェックポイントの基礎として使う**


この2層ユーザーレベルアプローチは、Linuxオペレーティングシステムでは潜在的な利点があります.DMTCPは、すでに存在する可能性がある他のシングルプロセスチェックポイントパッケージを実行するように移植できます。

**チェックポイントは、実行時に共有ライブラリを注入する**ことで任意のアプリケーションに追加されます。 
このライブラリ：
・**すべてのユーザープロセスでチェックポイント管理スレッドを起動します。**
・**作成時にオープンソケットに関する情報を記録するために、少数のlibc関数の周りにラッパーを追加する。**

**システムコールとprocファイルシステムはカーネルの状態を調べるためにも使われます。**

**カーネルバッファ内の"ネットワーク上の"データは、受信者プロセスのメモリにフラッシュされ、チェックポイントイメージに保存**されます。チェックポイントまたは再起動後、**このネットワークデータは元の送信者に返送され、ユーザースレッドを再開する前に再送信されます。**

再起動時には、新しいホストに移行されたプロセスの新しいアドレスを検出するための検出サービスが追加で必要になります。

### 4.2. Initialization of an application process under DMTCP

新しいプロセスの起動時にdmtcp_checkpointが注入される
**dmtcphijack.soは、チェックポイントを担当するDMTCPライブラリで、ユーザープログラムに入っています。**

ライブラリインジェクションは現在、LD_PRELOADを使用して行われています。

ライブラリの注入は、プログラムの起動後[35]、または他のアーキテクチャでも行うことができます。

ユーザプロセスに注入されると、DMTCPは単一のプロセスチェックポインターであるmtcp.soを呼び出し、さらに
DMTCPとの統合を可能にするルーチンをセットアップする

DMTCPは、少数のlibc関数の周りにラッパーを追加します。
これは、**我々のライブラリでlibcシンボルを上書きすることによって行われます。**

効率の理由から、**頻繁に呼び出されるシステムコール（読み書きなど）はラップしないようにします。**
DMTCPは、すべてのforkされた子プロセス、リモートプロセス（例えば、execからsshプロセスへの）を作成しようとするすべての試み、およびすべてのソケットが作成されるパラメータを意識する必要があるため、ラッパーが必要です。

**ソケットの場合、DMTCPはソケットがTCP / IPソケット、UNIXドメインソケット、または擬似端末であるかどうかを知る必要があります。**
DMTCPは、次の機能を包むラッパーを配置します：
**socket,  connect,  bind,  listen,  accept,  setsockopt,
fexecve, execve, execv, execvp, fork, close, dup2, socketpair,
openlog, syslog, closelog, ptsname and ptsname_r. **

このセクションの残りの部分では、これらのラッパーの目的について説明します。

### 4.3. Checkpointing under DMTCP

チェックポイントは、7つの段階と6つのグローバルなバリアを経て進められます。
グローバルなバリアはピアツーピア通信やブロードキャストツリーを通じて効率的に実装できますが、実装の簡素化のために現在は集中化されています。

次に、クラスタ全体をチェックポイントするためのDMTCP分散アルゴリズムを示します。 各ユーザープロセスで非同期**(asynchronously)**に実行されます。

使用される唯一の通信プリミティブは、クラスタ全体のバリアです。
次のステップは、図1に図式的に示されています。

**1）**
通常の実行：
各プロセスの**チェックポイント・マネージャ・スレッド(checkpoint manager thread)**は、コーディネータによって新しいチェックポイントが要求されるまで待機します。
これは、チェックポイント時まで解放されない特別なバリアで待機することによって行われます。

**2）**
ユーザスレッドを一時停止する：
MTCPはすべてのユーザースレッドを中断し、DMTCPは各ファイル記述子(fd)の所有者**(owner)**を保存します。
次に、DMTCPは、すべてのアプリケーションプロセスがバリア2(「中断」)に到達するまで待機し,それからバリアを解放します。

**3）**
FDの指導者(**shard FD leaders**)を選出する：
DMTCPは、潜在的に共有される各ファイル記述子のリーダーの選出を実行します。
fcntlのF_SETOWNフラグを使用し、オペレーティングシステムを騙してリーダーを選出します。
>**ファイルディスクリプター fd のイベント発生を知らせるシグナル SIGIO や SIGURG を受けるプロセスの プロセス ID またはプロセスグループID を arg で指定された ID に設定**
>ファイルディスクリプターがソケットを参照している場合は、 F_SETOWN を使用して、ソケットに帯域外 (out-of-band) データが届いた時に SIGURG シグナルを配送する相手を選択することもできる

すべてのプロセスが所有者を設定し、最後のプロセスが選挙に勝利します。
ステップ4では、fcntl（fd、F_GETOWN）== getpid（）をテストすることによって、プロセスがソケットfdの選挙リーダーかどうかをテストできます。

**F_SETOWNの元の値は、カーネルバッファが再充填された後に復元されます。**
DMTCPは、すべてのアプリケーションプロセスがバリア3(「選挙」)に達するまで待機します。完了したら、バリアを解放する。

**4）**
カーネルバッファを排除**(drain)**し、ピアとハンドシェイクを実行します。

各ソケットについて、対応する選挙リーダーは特別なトークンを送ることによってそのソケットを**フラッシュ(=バッファが満杯になっていなくてもバッファの内容を物理的記憶装置に書き込む)**する。

その後、使用可能なデータがなくなり、特別なトークンが見えるようになるまで、ソケットを廃棄(drain)します。

次にDMTCPは**すべてのソケットピアのハンドシェイクを実行して、すべてのソケットのリモート側のグローバル一意のIDを検出**します。

**接続情報テーブルはディスクに書き込まれます。**
次に、DMTCPは、すべてのアプリケーションプロセスがバリア4(「drain」)に到達するまで待機します

**5）**
ディスクにチェックポイントを書き込む：
すべてのソケットバッファの内容は、ユーザー空間にあります。

MTCPはすべてのユーザー空間のメモリをチェックポイントファイルに書き込みます。

DMTCPは、すべてのアプリケーションプロセスがバリア5(「checkpointed」)に達するまで待機します。

**6）**
カーネルバッファを補充(refill)する：
次に、DMTCPは、排出された**(drained)**ソケットバッファデータを**送信者に送り返す**。

**送信者は、データを再送信してカーネルソケットバッファを再充填します。**

次に、DMTCPは、すべてのアプリケーションプロセスがバリア6(「refilled」)に達するまで待機します

**7）**
ユーザスレッドを再開する：
MTCPはアプリケーションスレッドを再開し、DMTCPはステップ1に戻ります。

## 4.4. Restart under DMTCP

再起動プロセスは、共有ソケットを復元するためにいくらか複雑になります。
UNIXセマンティクスでは、複数のプロセスが単一のソケット接続を共有することがあります。

あるプロセスが開いているすべてのファイル記述子をフォークすると、子と親の間で共有されるようになります。
これを処理するために、**ソケットをグローバルに一意のID（hostid、pid、タイムスタンプ、プロセス単位の接続番号）で参照し、再起動時に重複を検出**できます。

これらの**グローバルにユニークなソケットID**（およびその他のメタ情報）は、各プロセスの接続情報テーブルのチェックポイント時に**記録されている。**

共有ソケットを再作成するには、各ホストに1つのDMTCP restart processが作成されます。
この単一のrestart processは、まずすべてのソケットを復元し、forkを実行してそのホスト上の個々のユーザープロセスを作成します。

**1）**
ファイルを再オープンし、ptysを再作成する：
リモートプロセスに接続されているソケットを除くファイル記述子は、最初に再生成されます。

これらには、ファイル、リッスンソケット、初期化されていないソケット、疑似ターミナルが含まれます。

**2）**
ソケットを再作成して再接続する：
各ソケットに対して、再起動プログラムは、クラスタ全体の検出サービスを使用して、対応する再起動プロセスの新しいアドレスを検索します。

新しいアドレスが見つかると、接続は再確立されます。 プロセスがチェックポイントと復元の間で再配置される可能性があるため、検出サービスが必要です。

**3）**
ユーザープロセスへのフォーク：
DMTCP再始動プログラムは、N個のプロセスに分岐します。ここで、Nは番号です
復元しようとしているユーザープロセスの数。

**4）**
ユーザープロセスのFDの再調整：
これらの各プロセスは、dup2を使用してファイルを再配置します
ディスクリプタを使用して、チェックポイント前の配置を反映させます。

他のプロセスに属する不要なファイル記述子は閉じられます。
共有ファイル記述子は、複数のプロセスに存在するようになりました。

**5）**
メモリとスレッドを復元する：
**MTCP再起動ルーチンが呼び出され、ローカルプロセスメモリとスレッドが復元**されます。

完了すると、ユーザプロセスはセクション4.3のチェックポイントアルゴリズムのバリア5で再開する

**6）**
カーネルバッファを補充する：
プログラムは、チェックポイントのステップ6で、ディスクにチェックポイントを書き終わったかのように再開します。

**7）**
ユーザスレッドを再開する：
プログラムはチェックポイント設定のステップ7を実行し続けます。

**上記のステップ2はさらに説明をする。** => **connectionrewirer.cppの説明**
**チェックポイントの前に**、新しい接続が受け入れられるたびに、システムコールの周りのラッパーがconnetとacceptの情報を転送したことを思い出してください。この情報には、**プロセスが再配置されても一定であるグローバルに一意のソケットID**が含まれます。
再起動時に、acceptまたはeachソケットは、再起動リスターソケットのアドレスとポートを検出サービスに通知します。
この告知を接続または受信すると、その告知への新しい接続が開かれます。
両者はハンドシェイクを行い、復元されているソケットに同意します。
最後に、dup2が各側で使用されて、ソケット記述子を正しい場所に移動します。
このプロセスは、すべてのソケットが復元されるまで非同期的に続行されます。
私たちの方法論は、ソケットのmigrationの両面をサポートしています。
また、ループバックソケットもサポートしています。

## 4.5. Implementation Strategies

この実装では、パイプ、共有メモリ（mmap経由）、および仮想pidのサポートの面で**明らかにならない問題が発生します。**

セクション4.3と4.4で見られるように、ソケット接続のネットワークデータをチェックポイントする戦略は、受信者がソケットをユーザー空間に流し、チェックポイントイメージを書き、最後に送信者に対して同じソケットを介してネットワークデータを再送信。
**パイプをサポートするために、パイプシステムコールのラッパーはパイプをソケットに昇格させます。**

共有メモリの場合、共有メモリセグメントのバッキングファイルがなく、ディレクトリ書き込みパーミッションがある場合は、新しいバッキングファイルを作成します。
次に、バッキングファイルが存在し、書き込みアクセス権があると仮定すると、共有メモリセグメントをチェックポイントイメージのデータで上書きします。
2つのプロセスがこのメモリを共有する場合、セグメントはチェックポイントの時点で共有されているため、同じ共有セグメントに書き込みますが、同じデータを書き込みます。

仮想pid（プロセスID）をサポートするには、pidの競合を心配する必要があります。
元のpidプロセスが最初にforkを呼び出して作成されると、そのpidも仮想PIDになり、その仮想PIDは後続の再起動の世代を通して維持されます。
したがって、新しいプロセスはpid Aを持つ可能性があります。
チェックポイントと再起動後、同じpid Aを使用して2番目のプロセスを作成することができます。
forkのラッパーがこの状況を検出し、競合する仮想PIDで子を終了させ、再度フォークします。

## 5.2. Distributed Applications
- **Run using OpenMPI (1.2.4):**
	- NAS NPB2.4:

DMTCPのオプションの機能は、ユーザスレッドを再開する前にカーネル書き込みバッファが空になるのを待つためにチェックポイントの後に同期を発行することです。

表示された結果は、同期を呼び出すことはありません。

これは、関連作業で最も一般的なタイミング方法論と一致しています。

同期を発行するコストは、チェックポイントのサイズとディスク速度に基づいて簡単に推定できます。
例として、ParGeant4（圧縮が有効）に対して同期が発行された場合、追加の平均コスト0.79秒（標準偏差0.24）が発生します。

代わりに、以前のチェックポイントを同期させることもできます。
これには、ほとんどの場合ディスクを待つことなく、最後のチェックポイント以外のすべての整合性を保証するという利点があります。


##6. Conclusions and Future Work
128の分散コア（32ノード）では、フォークされたチェックポイントを使用することで、通常のチェックポイント時間は2秒または0.2秒で、実行時間のオーバーヘッドはごくわずかです。これにより、頻繁なチェックポイントと対話型アプリケーションのチェックポイント処理中のアプリケーションの中断を最小限に抑えるために、DMTCPが魅力的になります。
**今後の作業は、ptraceシステムコールを完全にサポートし、gdbセッションのチェックポイント設定を完全にサポートします。**

